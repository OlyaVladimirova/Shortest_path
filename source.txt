#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <ctime>

const int infinity = INT_MAX;  //обозначение несуществующего пути из одной вершины в другую


class Graph {
	typedef std::pair<int, int> p_type; //здесь храним длину пути и вершину, через который мы этот путь будем корректировать
	size_t size;  //размер графа (кол-во вершин)
	p_type **matrix;  //матрица смежности
	//std::vector<int> V;  //вектор вершин
public:
	//конструктор графа через ввод из файла
	Graph(std::ifstream &in) {
		in >> size;

		matrix = new p_type*[size];
		for (size_t i = 0; i < size; ++i) matrix[i] = new p_type[size];
		for (size_t i = 0; i < size; ++i) {
			for (size_t j = 0; j < size; ++j) {
				in >> matrix[i][j].first;
				matrix[i][j].second = i;
			}
		}
	}

	//конструктор графа, генерирующий рандомный граф размером size
	//с вероятностью появления веса длиной бесконечность = 1/cnance_infinity
	//с диапазоном весов = range_of_weights
	Graph(size_t size, size_t chance_infinity = 3, int range_of_weights = 10)
	:size(size)
	{
		srand(time(NULL));
		size_t chance;
		matrix = new p_type*[size];
		for (size_t i = 0; i < size; ++i) matrix[i] = new p_type[size];

		for (size_t i = 0; i < size; ++i) {
			for (size_t j = 0; j < size; ++j) {
				if (i == j) {
					matrix[i][j].first = 0;
					matrix[i][j].second = i;
				}
				else {
					chance = rand() % chance_infinity;
					if (chance) {
						matrix[i][j].first = rand() % range_of_weights;
						/*chance = rand() % 2;
						if (chance) matrix[i][j].first = rand() % range_of_weights;
						else matrix[i][j].first = -(rand() % range_of_weights);*/
					}
					else
						matrix[i][j].first = infinity;
					matrix[i][j].second = i;
				}
			}
		}
	}

	//вывод матрицы на экран
	void show() {
		for (size_t i = 0; i < size; ++i) {
			for (size_t j = 0; j < size; ++j) {
				if (matrix[i][j].first == infinity)
					std::cout << "oo" << "," << matrix[i][j].second << "\t\t";
				else
					std::cout << matrix[i][j].first << "," << matrix[i][j].second << "\t\t";
			}
			std::cout << std::endl;
		}
	}

	//дальше методы нашего алгоритма
	void alg_floyd() {
		int x;
		for (size_t k = 0; k < size; ++k) {
			for (size_t i = 0; i < size; ++i) {
				for (size_t j = 0; j < size; ++j) {
					if ((k == i) || (k == j) || (i == j) 
						|| (matrix[i][k].first == infinity) || (matrix[k][j].first == infinity)) continue;
					if (matrix[i][j].first >= (matrix[i][k].first + matrix[k][j].first)) {
						x = (matrix[i][k].first + matrix[k][j].first);
						matrix[i][j].first = x;
						matrix[i][j].second = k;
					}
				}
			}
		}
	}

	void short_path(int x, int y) {
		if (matrix[x][y].first == infinity) std::cout << "There is no path from " << x << " to " << y << std::endl;
		else {
			std::cout << x <<" -> ";
			short_path_main(x, y);
			std::cout << y << '\n';
		}
	}

	void short_path_main (int x, int y) {
		if ((matrix[x][y].second == y) || (matrix[x][y].second == x)) return;
		
		
		if (matrix[x][y].second != x) {
			
			short_path_main(x, matrix[x][y].second);
			std::cout << matrix[x][y].second << " -> ";
			short_path_main(matrix[x][y].second, y);
			
		}
	}


};

int main()
{
	std::ifstream in("input.txt");
	Graph object(3);
	object.show();
	std::cout << "\n\n";
	object.alg_floyd();
	object.show();
	std::cout << "Enter vertexes: \n";
	int x, y;
	std:: cin >> x >> y;
	object.short_path(x, y);

	system("pause");
    return 0;
}